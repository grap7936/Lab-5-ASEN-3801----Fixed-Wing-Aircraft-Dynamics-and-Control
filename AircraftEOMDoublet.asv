function xdot = AircraftEOMDoublet(time, aircraft_state, aircraft_surfaces, doublet_size, doublet_time, wind_inertial, aircraft_parameters)

%% Purpose:
% Define derivative of a state vector of 12 x N components for input into ode45 to achieve a final
% state vector and how it evolves w.r.t time with a doublet added to elevator control input

% Inputs: 
% 1.) t == time --> time steps will be decided automatically by the computer when used in ode45
% 2.) aircraft_state == state vector of 12 x N that will be numerically integrated to solve for by the computer
% 3.) aoircraft_surfaces == vector of four aircraft surfaces including [delta_e, delta_a, delta_r, delta_t]^T
% 4.) doublet_size == size of doublet portion added to elevator control surface, delta_e
% 5.) doublet_time == time the doublet pulses in conjunction with the elevator control surface
% 6.) wind_inertial == the wind vector expressed in inertial coordinates as: [w_x, w_y, w_z]^T
% 7.) aircraft_parameters == necessary coefficients and structural parameters of the twistor aircraft
% 8.) control_input0 == initial conditions for controls read in to determine trim variables. Has 
% form [delta_e_trim, delta_a_trim, delta_r_trim, delta_t_trim]^T



%% Upacking 
% Unpack the state vector
% x_E = aircraft_state(1);
% y_E = aircraft_state(2);
z_E = aircraft_state(3);
phi = aircraft_state(4);
theta = aircraft_state(5);
psi = aircraft_state(6);
u_E = aircraft_state(7);
v_E = aircraft_state(8);
w_E = aircraft_state(9);
p = aircraft_state(10);
q = aircraft_state(11);
r = aircraft_state(12);


%% Additional set up

% Rotation matrix from interial to body
R_BI = [ cos(theta)*cos(psi),  sin(phi)*sin(theta)*cos(psi)-cos(phi)*sin(psi),  cos(phi)*sin(theta)*cos(psi)+sin(phi)*sin(psi);
         cos(theta)*sin(psi),  sin(phi)*sin(theta)*sin(psi)+cos(phi)*cos(psi),  cos(phi)*sin(theta)*sin(psi)-sin(phi)*cos(psi);
        -sin(theta),           sin(phi)*cos(theta),                             cos(phi)*cos(theta)                          ];

% Get density
density = stdatmo(z_E);

% Get gammas
[~, Gamma] = gammas(aircraft_parameters);



delta_e_trim = aircraft_surfaces(1);

%% Create if statements to define delta_e with respect to time (i.e designed as a piecewise function)

% Preallocate variable sizes
delta_e = zeros(1, length(time));

% Loop

for i  = 1:length(time)

if 0 < time(i) && time(i) <= doublet_time
    
    delta_e(i) = delta_e_trim + doublet_size;
    
elseif doublet_time < time(i) && time(i) <= 2*doublet_time
    
    delta_e(i) = delta_e_trim - doublet_size;
    
elseif time(i) >= 2*doublet_time
    
    delta_e(i) = delta_e_trim;
    
end

end

surfaces_new = [delta_e(i), aircraft_surfaces(2), aircraft_surfaces(3), aircraft_surfaces(4)];

%% Calculate the vector derivative

% Position changes (xdot_E, ydot_E, zdot_E)
xdot(1:3) = R_BI * [u_E; v_E; w_E]; 

% Euler Angle changes (phidot, thetadot, psidot)
xdot(4:6) = [1,     sin(phi)*tan(theta),        cos(phi)*tan(theta);
             0,     cos(phi),                   -sin(phi);
             0,     sin(phi)*sec(theta),        cos(phi)*sec(theta)] * [p; q; r];


% Get aero forces and monets from the function
[aero_forces, aero_moments] = AeroForcesAndMoments(aircraft_state, surfaces_new, wind_inertial, density, aircraft_parameters);


% Velocity changes (udot_E, vdot_E, wdot_E)
xdot(7) = r*v_E - q*w_E - aircraft_parameters.g*sin(theta) + (aero_forces(1)/aircraft_parameters.m);
xdot(8) = p*w_E - r*u_E + aircraft_parameters.g*cos(theta)*sin(phi) + (aero_forces(2)/aircraft_parameters.m);            
xdot(9) = q*u_E - p*v_E + aircraft_parameters.g*cos(theta)*cos(phi) + (aero_forces(3)/aircraft_parameters.m);


% attitude rate changes (pdot, qdot, rdot)
xdot(10) = (Gamma(1) * p * q - Gamma(2) * q * r) + (Gamma(3) * aero_moments(1) + Gamma(4) * aero_moments(3));
xdot(11) = (Gamma(5) * p * r - Gamma(6) * (p^2 - r^2)) + (1 / aircraft_parameters.Iy * aero_moments(2));
xdot(12) = (Gamma(7) * p * q - Gamma(1) * q * r) + (Gamma(4) * aero_moments(1) + Gamma(8) * aero_moments(3));

xdot = xdot';

end
